## 图像渲染至屏幕的详细过程

一张图片从文件格式最终被渲染到屏幕上，是一个涉及CPU和GPU协同工作的复杂管线过程。以下以OpenGL ES为例，详细阐述其步骤。

### 1.1 数据加载与解码（CPU端）

- **步骤1：读取文件**。应用程序从磁盘存储中读取图片的二进制文件（如PNG、JPEG）。
- **步骤2：解码**。将压缩的图片格式解码为GPU能够理解的原始像素数据，通常是一个在内存中连续排列的RGB或RGBA字节数组。

### 1.2 纹理上传（CPU -> GPU）

- **步骤3：创建纹理对象**。在GPU端，通过`glGenTextures`等API创建一个纹理对象，并为其分配一个标识符。
- **步骤4：传输数据**。使用`glTexImage2D`等函数，将步骤2中解码得到的像素数据从CPU内存传输到GPU的显存中。这个过程通过CPU到GPU总线进行，可能成为瓶颈。

### 1.3 渲染管线处理（GPU端）

一旦数据进入GPU，图形渲染管线便开始工作，其核心流程如下：

1.  **顶点着色器（Vertex Shader）**：
    - 对输入的顶点进行处理。如果渲染的只是一个简单的2D四边形（两个三角形），那么顶点着色器主要负责将四边形的四个顶点从局部坐标变换到屏幕坐标（通常通过一个变换矩阵）。 它还可以计算和传递诸如纹理坐标、颜色等变量给后续阶段。

2.  **图元装配（Primitive Assembly）**：
    - 将顶点着色器输出的顶点组装成指定的图元（如三角形）。对于2D图片，就是组装两个三角形形成一个矩形。

3.  **光栅化（Rasterization）**：
    - 将组装好的图元（矩形）转换为屏幕上的一个个像素点，这个过程生成了所谓的**片元（Fragment）**。

4.  **片元着色器（Fragment Shader）**：
    - 这是决定像素最终颜色的关键阶段。 片元着色器会对每个片元（即每个像素候选点）执行程序。
    - 对于图片渲染，片元着色器的主要工作是**纹理采样**：根据当前片元对应的纹理坐标，从我们之前上传的纹理中取出相应的颜色值。 它还可以进行颜色混合、光照计算（如果是3D场景）等操作。

### 1.4 最终输出与显示

- **步骤5：写入帧缓冲区**：片元着色器计算出的颜色值会被写入一个特殊的内存区域——**帧缓冲区（Framebuffer）**。
- **步骤6：屏幕显示**：显卡会周期性地读取帧缓冲区中的内容，并将其输出到显示屏上，最终形成我们看到的图像。

---

## 2. 内存与显存的生命周期管理

图片在渲染过程中会同时存在于两个不同的内存空间中：**CPU内存（系统内存）**和**GPU显存**。这两部分内存是相互独立的，需要分别管理和释放。

### 2.1 CPU内存的生命周期

#### 2.1.1 创建与使用

在步骤2（解码）中，解码后的像素数据会被存储在CPU的系统内存中：

```cpp
// 使用 stb_image 库加载图片
unsigned char *data = stbi_load("assets/container.jpg", &width, &height, &nrChannels, 0);
```

此时，`data` 指向的内存区域包含了解码后的原始像素数据（通常是 `width × height × nrChannels` 字节）。

**内存特点：**
- 存储在CPU可访问的系统内存（RAM）中
- 数据格式为未压缩的RGB或RGBA字节数组
- 使用C/C++标准内存管理（malloc/free或new/delete）

#### 2.1.2 释放

CPU内存应该在数据上传到GPU后立即释放，因为：

1. **数据已经复制到GPU**：通过`glTexImage2D`上传后，GPU已拥有完整副本
2. **减少内存占用**：未压缩的像素数据通常很大（如1920×1080的RGBA图片约8MB），保留会造成不必要的内存浪费
3. **避免内存泄漏**：如果忘记释放，每次加载纹理都会累积内存占用

**正确的释放方式：**

```cpp
glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, 
              GL_RGB, GL_UNSIGNED_BYTE, data);
glGenerateMipmap(GL_TEXTURE_2D);  // 可选：生成多级渐远纹理

// 立即释放CPU内存，此时GPU已拥有数据的独立副本
stbi_image_free(data);
```

**常见错误：**
- ❌ 忘记调用`stbi_image_free(data)`
- ❌ 在`glTexImage2D`之前就释放了数据
- ❌ 在程序退出前一直没有释放

### 2.2 GPU显存的生命周期

#### 2.2.1 创建

在步骤3中，通过`glGenTextures`创建纹理对象：

```cpp
unsigned int texture;
glGenTextures(1, &texture);
```

**关键理解：**
- `glGenTextures`只是分配一个纹理对象的**标识符**（ID），并不立即分配显存
- 这个ID只是OpenGL用来标识纹理对象的句柄，类似于文件描述符
- 此时GPU显存中还没有实际的纹理数据

#### 2.2.2 分配与上传

在步骤4中，通过`glTexImage2D`时才真正分配GPU显存：

```cpp
glBindTexture(GL_TEXTURE_2D, texture);
glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, 
              GL_RGB, GL_UNSIGNED_BYTE, data);
```

**此时GPU显存的状态：**
- OpenGL在GPU显存中分配了一块连续的内存区域
- 大小约为 `width × height × nrChannels` 字节（加上可能的对齐）
- 如果生成了多级渐远纹理（mipmap），显存占用会更大（约为原大小的1.33倍）
- 数据从CPU内存通过PCIe总线传输到GPU显存

#### 2.2.3 释放

GPU显存通过`glDeleteTextures`释放：

```cpp
glDeleteTextures(1, &texture);
```

**关键特性：**

1. **延迟删除机制**：OpenGL采用延迟删除（deferred deletion）：
   - `glDeleteTextures`调用后，纹理对象被标记为"已删除"
   - 但实际显存的释放可能发生在该纹理不再被任何渲染命令引用时
   - 这是为了避免正在渲染的纹理被突然删除导致的问题

2. **纹理对象的引用计数**：
   - 如果一个纹理正在被某个渲染命令使用，删除操作会被延迟
   - OpenGL内部维护引用计数，当引用计数为0时才真正释放显存

3. **绑定状态的影响**：
   ```cpp
   // 如果纹理当前被绑定，应该先解绑再删除（最佳实践）
   glBindTexture(GL_TEXTURE_2D, 0);  // 解绑
   glDeleteTextures(1, &texture);     // 然后删除
   ```

### 2.3 CPU内存与GPU显存的关系

#### 2.3.1 独立性

**重要：CPU内存和GPU显存是完全独立的两个存储空间：**

- **物理位置不同**：CPU内存位于系统RAM，GPU显存位于显卡的独立内存（或共享系统内存）
- **访问权限不同**：CPU可以直接访问系统内存，但不能直接访问GPU显存（需要通过驱动和PCIe总线）
- **生命周期独立**：两者的分配和释放互不影响

#### 2.3.2 数据复制关系

在`glTexImage2D`调用时：

1. **数据复制**：CPU内存中的数据被**复制**（而非移动）到GPU显存
2. **独立存在**：复制完成后，CPU内存和GPU显存中各有一份完整的数据副本
3. **异步传输**：数据传输可能是异步的，但`glTexImage2D`返回时保证数据已到达GPU

**这解释了为什么可以立即释放CPU内存：**
```cpp
glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, 
              GL_RGB, GL_UNSIGNED_BYTE, data);
// 此时数据已在GPU显存中，CPU内存中的data不再需要
stbi_image_free(data);  // 可以安全释放
```

#### 2.3.3 更新纹理数据

如果需要更新已经上传的纹理数据，有两种方式：

1. **重新上传整个纹理**（使用`glTexImage2D`）：
   ```cpp
   unsigned char *newData = stbi_load("new_texture.png", ...);
   glBindTexture(GL_TEXTURE_2D, texture);
   glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, 
                 GL_RGB, GL_UNSIGNED_BYTE, newData);
   stbi_image_free(newData);
   ```

2. **更新部分纹理**（使用`glTexSubImage2D`，更高效）：
   ```cpp
   // 只更新纹理的一部分，不需要重新分配整个纹理
   glTexSubImage2D(GL_TEXTURE_2D, 0, xoffset, yoffset, 
                   subWidth, subHeight, GL_RGB, GL_UNSIGNED_BYTE, subData);
   ```

### 2.4 释放顺序与最佳实践

#### 2.4.1 推荐的释放顺序

虽然CPU内存和GPU显存相互独立，但建议按以下顺序释放：

```cpp
// 1. 首先确保没有渲染命令正在使用该纹理
glBindTexture(GL_TEXTURE_2D, 0);  // 解绑纹理

// 2. 删除GPU纹理对象（释放显存）
glDeleteTextures(1, &texture);

// 3. CPU内存应该在glTexImage2D之后就已释放（如果还没释放的话）
stbi_image_free(data);  // 如果之前已释放，这行不会有问题（stbi_image_free处理NULL指针）
```

**为什么先解绑再删除？**
- 确保删除时纹理不在活跃状态
- 避免某些OpenGL实现中的潜在问题
- 代码更清晰，符合最佳实践

#### 2.4.2 完整的内存管理示例

```cpp
// ========== 初始化阶段 ==========
unsigned int texture;
glGenTextures(1, &texture);
glBindTexture(GL_TEXTURE_2D, texture);

// 加载并上传纹理
unsigned char *data = stbi_load("assets/texture.jpg", &width, &height, &nrChannels, 0);
if (data) {
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, 
                  GL_RGB, GL_UNSIGNED_BYTE, data);
    glGenerateMipmap(GL_TEXTURE_2D);
    stbi_image_free(data);  // ← CPU内存立即释放
    data = nullptr;  // 安全起见，设置为空指针
} else {
    std::cerr << "Failed to load texture" << std::endl;
    glDeleteTextures(1, &texture);  // 加载失败时也要清理
    return;
}

// ========== 渲染循环中使用 ==========
// （纹理对象一直被保留在GPU显存中，直到不再需要）

// ========== 清理阶段 ==========
glBindTexture(GL_TEXTURE_2D, 0);      // 1. 解绑
glDeleteTextures(1, &texture);         // 2. 删除GPU纹理
// 3. CPU内存已在初始化后释放
```

#### 2.4.3 常见的内存泄漏场景

1. **CPU内存泄漏**：
   - ❌ 忘记调用`stbi_image_free(data)`
   - ❌ 在异常情况下未释放（应使用RAII或异常处理）

2. **GPU显存泄漏**：
   - ❌ 忘记调用`glDeleteTextures`
   - ❌ 纹理ID丢失但未删除（例如局部变量存储纹理ID，函数返回后无法访问但对象仍存在）

3. **双重释放**：
   ```cpp
   stbi_image_free(data);
   stbi_image_free(data);  // ❌ 错误：对同一指针释放两次
   ```
   注：`stbi_image_free`通常处理NULL指针是安全的，但重复释放非空指针会导致未定义行为

#### 2.4.4 资源管理的现代实践

使用C++的RAII（Resource Acquisition Is Initialization）原则：

```cpp
class Texture {
private:
    unsigned int textureID;
    
public:
    Texture(const char* path) {
        glGenTextures(1, &textureID);
        // ... 加载和上传纹理 ...
    }
    
    ~Texture() {
        glDeleteTextures(1, &textureID);  // 自动释放
    }
    
    // 禁用拷贝，避免重复删除
    Texture(const Texture&) = delete;
    Texture& operator=(const Texture&) = delete;
    
    // 允许移动
    Texture(Texture&& other) noexcept : textureID(other.textureID) {
        other.textureID = 0;
    }
};

// 使用示例：自动管理生命周期
{
    Texture tex("assets/texture.jpg");
    // 使用纹理...
} // tex超出作用域时自动调用析构函数，释放GPU资源
```

### 2.5 内存占用估算

了解内存占用有助于优化性能：

**CPU内存占用（解码后）：**
```
大小 = width × height × channels × sizeof(unsigned char)
例如：1920 × 1080 × 4 (RGBA) × 1 字节 = 8,294,400 字节 ≈ 7.9 MB
```

**GPU显存占用：**
```
基础纹理 = width × height × channels × sizeof(unsigned char)
如果生成mipmap：
总占用 ≈ 基础纹理 × 1.33（近似值）

例如：1920 × 1080 × 4 × 1 × 1.33 ≈ 10.5 MB
```

**注意事项：**
- 实际显存占用可能因GPU对齐要求而略有不同
- 压缩纹理格式（如DXT/BC、ETC2）可以显著减少显存占用
- 大纹理会快速耗尽显存，需要合理规划纹理大小和数量

---

## 3. 图片压缩格式详解

### 3.1 磁盘格式 vs GPU压缩纹理格式

理解两种不同类型的格式至关重要：

1. **磁盘存储格式**（如PNG、JPEG、WebP）
   - 用于文件系统的存储
   - 需要CPU解码才能上传到GPU
   - 解码后通常展开为未压缩的RGBA数据

2. **GPU压缩纹理格式**（如DXT/BC、ETC2、ASTC）
   - 直接存储在GPU显存中
   - GPU硬件直接支持解码，无需CPU参与
   - 显著减少显存占用，提升性能

### 3.2 各平台推荐的纹理格式

**重要提示：** 以下推荐基于**原生应用**（通过OpenGL ES直接访问GPU）。如果是**WebH5应用**（通过WebGL），请参考3.7节的特殊说明。

#### 3.2.1 Android平台（原生应用）

**推荐格式：**

1. **ASTC (Adaptive Scalable Texture Compression)** ⭐ **首选**
   - 压缩比可变（4x4到12x12块）
   - 质量优于ETC2
   - Android 5.0+（API 21+）支持，现在覆盖率>95%
   - **推荐用于：所有现代Android应用（2024年首选）**

2. **ETC2 (Ericsson Texture Compression 2)**
   - OpenGL ES 3.0+标准要求
   - Android 4.3+（API 18+）普遍支持
   - 推荐用于：需要兼容较旧设备，或引擎不支持ASTC

3. **ETC1**
   - OpenGL ES 2.0兼容
   - 所有Android设备支持
   - 缺点：不支持Alpha通道（需要单独处理）
   - 推荐用于：极度重视兼容性的场景

**格式选择策略（2024年更新）：**
```
原生Android应用：
  现代应用（推荐）→ ASTC 4x4
  兼容性优先 → ETC2
  极致兼容 → ETC1

WebH5应用：
  ⚠️ ASTC不可用，请参考3.7节
```

#### 3.2.2 iOS平台（原生应用）

**推荐格式：**

1. **ASTC (Adaptive Scalable Texture Compression)** ⭐ **首选**
   - iOS设备从A8芯片开始支持
   - iOS 9+系统支持（2024年覆盖率>99%）
   - 压缩比和质量优于PVRTC
   - **推荐用于：所有现代iOS应用（2024年首选）**

2. **PVRTC (PowerVR Texture Compression)**
   - iOS设备原生支持（PowerVR GPU）
   - PVRTC 4bpp：压缩比8:1（相对RGBA32），质量良好
   - PVRTC 2bpp：压缩比16:1（相对RGBA32），质量较低
   - 推荐用于：需要兼容iOS 8或更早版本

3. **未压缩格式**
   - 在小纹理或需要最佳质量时使用
   - 显存占用大，但质量无损

**格式选择策略（2024年更新）：**
```
原生iOS应用：
  现代应用（推荐）→ ASTC 4x4
  兼容iOS 8- → PVRTC 4bpp
  小纹理 (<64x64) → 未压缩 RGBA8888

WebH5应用：
  ⚠️ ASTC不可用，请参考3.7节
```

#### 3.2.3 Web平台（WebGL）

**推荐格式：**

1. **KTX2/Basis Universal**
   - 运行时转换为目标GPU支持的格式
   - 支持DXT、ETC1/ETC2、ASTC、PVRTC等
   - 单个文件适配多平台
   - 推荐用于：跨平台Web应用

2. **WEBP**
   - 浏览器原生支持，解码PROBABLY由浏览器完成
   - 适合作为磁盘存储格式
   - 上传到GPU前需要解码为RGBA

3. **DXT/BC格式（通过扩展）**
   - WEBGL_compressed_texture_s3tc扩展
   - 主要在Windows/Chrome/Firefox支持
   - 不适用于移动设备

**格式选择策略：**
```
跨平台兼容性优先 → KTX2/Basis Universal
性能关键 + 桌面浏览器 → S3TC (DXT)
存储优化 → WebP (作为磁盘格式)
```

### 3.3 常见压缩纹理格式详解

#### 3.3.1 DXT/BC格式（S3TC）

**平台支持：**
- Windows（DirectX标准）
- macOS/Linux（通过扩展）
- Web（通过WEBGL_compressed_texture_s3tc扩展）

**格式变体：**
- **DXT1/BC1**：RGB无Alpha，或1-bit Alpha（调色板）
  - 压缩比：6:1（相对RGB24）
  - 块大小：4×4像素 = 8字节

- **DXT3/BC2**：RGB + 4-bit Alpha
  - 压缩比：4:1（相对RGBA32）
  - 块大小：4×4像素 = 16字节

- **DXT5/BC3**：RGB + 插值Alpha
  - 压缩比：4:1（相对RGBA32）
  - 块大小：4×4像素 = 16字节
  - Alpha质量优于DXT3

**优点：**
- ✅ 压缩比高，显存节省明显
- ✅ GPU硬件解码，性能好
- ✅ 广泛支持（Windows/桌面Web）

**缺点：**
- ❌ 移动设备不支持
- ❌ 有损压缩，可能产生块状伪影
- ❌ Alpha通道质量有限（DXT1/3）

**内存计算：**
```
DXT1纹理大小 = ceil(width/4) × ceil(height/4) × 8 字节
DXT3/5纹理大小 = ceil(width/4) × ceil(height/4) × 16 字节

例如：512×512的DXT5纹理
= ceil(512/4) × ceil(512/4) × 16
= 128 × 128 × 16
= 262,144 字节 = 256 KB

对比未压缩RGBA8888：
512 × 512 × 4 = 1,048,576 字节 = 1 MB
压缩比 = 4:1
```

#### 3.3.2 ETC格式

**ETC1：**
- **平台支持**：所有Android设备（OpenGL ES 2.0+）
- **压缩比**：6:1（相对RGB24）
- **块大小**：4×4像素 = 8字节
- **特点**：不支持Alpha通道（需要通过两张纹理理论上支持）

**ETC2：**
- **平台支持**：OpenGL ES 3.0+（Android 4.3+）
- **压缩比**：
  - ETC2 RGB：6:1（相对RGB24）
  - ETC2 RGBA：4:1（相对RGBA32）
  - ETC2 RGBA8：4:1，高质量Alpha
- **块大小**：4×4像素 = 8字节（RGB）或16字节（RGBA）
- **特点**：质量优于ETC1，完整支持Alpha

**优点：**
- ✅ Android标准格式，兼容性好
- ✅ 压缩比高
- ✅ GPU硬件解码

**缺点：**
- ❌ ETC1不支持Alpha
- ❌ 有损压缩
- ❌ iOS不支持（需使用其他格式）

**内存计算：**
```
ETC1/ETC2 RGB大小 = ceil(width/4) × ceil(height/4) × 8 字节
ETC2 RGBA大小 = ceil(width/4) × ceil(height/4) × 16 字节

例如：1024×1024的ETC2 RGBA纹理
= ceil(1024/4) × ceil(1024/4) × 16
= 256 × 256 × 16
= 1,048,576 字节 = 1 MB

对比未压缩RGBA8888：
1024 × 1024 × 4 = 4 MB
压缩比 = 4:1
```

#### 3.3.3 PVRTC格式

**平台支持**：iOS设备（PowerVR GPU）

**格式变体：**
- **PVRTC 4bpp**：每像素4位
  - 压缩比：8:1（相对RGBA32）
  - 块大小：可变（最小8×4像素块）

- **PVRTC 2bpp**：每像素2位
  - 压缩比：16:1（相对RGBA32）
  - 质量较低

**优点：**
- ✅ iOS原生支持，性能优异
- ✅ 压缩比极高（4bpp为8:1）
- ✅ 支持Alpha通道

**缺点：**
- ❌ 仅iOS设备支持
- ❌ 对非方形纹理可能有额外限制
- ❌ 质量可能略低于ASTC

**内存计算：**
```
PVRTC 4bpp大小 = (width × height × 4) / 8 字节
PVRTC 2bpp大小 = (width × height × 2) / 8 字节

例如：1024×1024的PVRTC 4bpp纹理
= (1024 × 1024 × 4) / 8
= 524,288 字节 = 512 KB

对比未压缩RGBA8888：
1024 × 1024 × 4 = 4 MB
压缩比 = 8:1
```

#### 3.3.4 ASTC格式

**平台支持：**
- iOS 9+（A8芯片及更新）
- Android 5.0+（API 21+），需要硬件支持

**格式变体（块大小）：**
- **ASTC 4×4**：每块4×4像素，128位/块
  - 压缩比：8bpp（相对RGBA32）
  - 质量：优秀

- **ASTC 6×6**：每块6×6像素
  - 压缩比：约3.56bpp
  - 质量：良好，压缩比更高

- **ASTC 8×8**：每块8×8像素
  - 压缩比：2bpp
  - 质量：较低，但压缩比极高

**优点：**
- ✅ 压缩比可调，灵活性高
- ✅ 质量优于传统格式
- ✅ 支持HDR和3D纹理

**缺点：**
- ❌ 需要较新的硬件支持
- ❌ 压缩时间较长（离线处理）

**内存计算：**
```
ASTC块大小固定为128位（16字节）
ASTC 4×4大小 = ceil(width/4) × ceil(height/4) × 16 字节
ASTC 6×6大小 = ceil(width/6) × ceil(height/6) × 16 字节
ASTC 8×8大小 = ceil(width/8) × ceil(height/8) × 16 字节

例如：1024×1024的ASTC 4×4纹理
= ceil(1024/4) × ceil(1024/4) × 16
= 256 × 256 × 16
= 1,048,576 字节 = 1 MB

对比未压缩RGBA8888：
压缩比 = 4:1（虽然块大小看起来是4:1，但ASTC 4×4实际是8bpp，所以压缩比约为4:1）
```

#### 3.3.5 未压缩格式

**常见格式：**

1. **RGBA8888**：每像素32位（8位/通道）
   - 内存占用：width × height × 4 字节
   - 质量：无损

2. **RGB888**：每像素24位（8位/通道）
   - 内存占用：width × height × 3 字节
   - 质量：无损（无Alpha）

3. **RGBA4444**：每像素16位（4位/通道）
   - 内存占用：width × height × 2 字节
   - 质量：有损（色深减少）

**使用场景：**
- 小纹理（如UI图标）
- 需要无损质量的纹理
- 无法使用压缩格式的兼容性场景

### 3.4 磁盘占用 vs 内存占用 vs 显存占用

理解这三种占用空间的区别是优化性能的关键：

#### 3.4.1 磁盘占用（文件大小）

**定义**：图片文件在磁盘上存储的大小

**影响因素：**
- 压缩算法（PNG、JPEG、WebP等）
- 压缩质量设置
- 图片内容复杂度

**示例：**
```
一张1920×1080的图片：
- PNG格式：可能 500KB - 2MB（取决于内容）
- JPEG格式：可能 200KB - 800KB（取决于质量）
- WebP格式：可能 150KB - 600KB
- 未压缩RGBA：8.29 MB（固定）
```

#### 3.4.2 CPU内存占用（解码后）

**定义**：图片解码后，在CPU系统内存中占用的空间

**计算公式：**
```
CPU内存占用 = width × height × channels × sizeof(data_type)

例如：1920×1080 RGBA图片
= 1920 × 1080 × 4 × 1 字节
= 8,294,400 字节 ≈ 7.9 MB
```

**特点：**
- 与磁盘格式无关（解码后统一格式）
- 仅在解码和上传期间存在
- 上传到GPU后应该立即释放

#### 3.4.3 GPU显存占用（渲染时）

**定义**：纹理数据在GPU显存中占用的空间

**影响因素：**
1. **是否使用压缩纹理格式**：
   ```
   未压缩RGBA8888：width × height × 4 字节
   DXT5/ETC2 RGBA：约 width × height × 1 字节（4:1压缩）
   PVRTC 4bpp：约 width × height × 0.5 字节（8:1压缩）
   ```

2. **是否生成Mipmap**：
   ```
   含Mipmap的纹理 ≈ 基础纹理 × 1.33
   ```

3. **对齐要求**：
   - GPU可能要求纹理按特定字节对齐（如4、8、16字节）
   - 实际占用可能略大于理论值

#### 3.4.4 三者的关系与转换流程

```
磁盘文件（PNG/JPEG等）
    ↓ 读取（磁盘I/O）
磁盘占用 → CPU内存（解码后）
    ↓ 解码（CPU处理）
CPU内存占用（未压缩RGBA数据）
    ↓ glTexImage2D（CPU→GPU传输）
GPU显存占用（未压缩或压缩格式）
```

**重要区别：**

1. **磁盘 → CPU内存**：
   - **磁盘格式**：压缩格式（PNG/JPEG），小文件
   - **CPU内存格式**：未压缩RGBA，大文件
   - **转换**：CPU解码，扩展数据

2. **CPU内存 → GPU显存（未压缩上传）**：
   - **CPU内存格式**：未压缩RGBA，`width × height × 4` 字节
   - **GPU显存格式**：未压缩RGBA，`width × height × 4` 字节
   - **转换**：直接复制，大小不变

3. **CPU内存 → GPU显存（压缩格式上传）**：
   - **CPU内存格式**：解码后的未压缩RGBA，`width × height × 4` 字节
   - **磁盘格式（.ktx/.dds等）**：预压缩的GPU格式，小文件
   - **GPU显存格式**：压缩纹理（DXT/ETC等），`约 width × height × 1` 字节
   - **转换**：读取预压缩文件，直接上传到GPU，无需解码

#### 3.4.5 最佳实践：使用预压缩纹理

**传统方式（低效）：**
```
磁盘PNG文件（500KB）
  → 读取到内存
  → CPU解码为RGBA（7.9MB CPU内存）
  → 上传到GPU未压缩格式（7.9MB GPU显存）
  → 释放CPU内存
```

**优化方式（高效）：**
```
磁盘预压缩文件（如.ktx，含ETC2，约2MB）
  → 读取到内存（2MB CPU内存）
  → 直接上传压缩数据到GPU（约2MB GPU显存）
  → 释放CPU内存
  → GPU硬件解码（无需CPU参与）
```

**优势：**
- ✅ 磁盘占用小（虽然不是最小，但可直接用于GPU）
- ✅ CPU内存占用小（不需要解码）
- ✅ GPU显存占用小（压缩格式）
- ✅ 上传速度快（数据量小）
- ✅ 渲染性能好（GPU硬件解码）

**工具链：**
- **PVRTexTool**：生成PVRTC、ETC、ASTC格式
- **crunch**：生成DXT格式（带CRN压缩）
- **Basis Universal**：生成KTX2格式（跨平台）
- **astcenc**：生成ASTC格式

### 3.5 格式选择决策树

```
开始选择纹理格式
│
├─ 目标平台？
│   ├─ Android
│   │   ├─ OpenGL ES 3.0+? → ETC2
│   │   ├─ OpenGL ES 2.0? → ETC1（或未压缩）
│   │   └─ API 21+ + 高质量? → ASTC 4×4
│   │
│   ├─ iOS
│   │   ├─ iOS 9+ (A8+)? → ASTC 4×4（优先）
│   │   └─ iOS 8-? → PVRTC 4bpp
│   │
│   └─ Web (WebGL)
│       ├─ 跨平台兼容? → KTX2/Basis Universal
│       ├─ 桌面浏览器? → S3TC (DXT)
│       └─ 存储优化? → WebP（磁盘格式，需解码）
│
└─ 特殊需求？
    ├─ 小纹理 (<64×64)? → 未压缩RGBA8888
    ├─ 最高质量? → 未压缩格式或高质量ASTC
    ├─ 最小显存? → PVRTC 2bpp或ASTC 8×8
    └─ 动态生成? → 未压缩格式（运行时压缩性能差）
```

### 3.6 内存占用对比表

**假设纹理尺寸：1024×1024，RGBA格式**

| 格式 | 磁盘占用（典型） | CPU内存（解码后） | GPU显存 | 压缩比 |
|------|----------------|-----------------|---------|--------|
| PNG（磁盘格式） | 500KB - 2MB | 4 MB | - | - |
| JPEG（磁盘格式） | 200KB - 800KB | 4 MB | - | - |
| 未压缩RGBA8888 | - | 4 MB | 4 MB | 1:1 |
| DXT5/BC3 | - | 4 MB（解码后） | 1 MB | 4:1 |
| ETC2 RGBA | - | 4 MB（解码后） | 1 MB | 4:1 |
| PVRTC 4bpp | - | 4 MB（解码后） | 0.5 MB | 8:1 |
| ASTC 4×4 | - | 4 MB（解码后） | 1 MB | 4:1 |
| ASTC 8×8 | - | 4 MB（解码后） | 0.25 MB | 16:1 |

**说明：**
- 磁盘占用取决于压缩算法和内容，表中所列为典型值
- 使用GPU压缩格式时，通常使用磁盘上的预压缩文件（如.ktx），此时磁盘占用和GPU显存占用接近
- CPU内存占用只在加载和解码阶段存在，应尽快释放

### 3.7 移动平台WebH5游戏的纹理格式选择

对于没有KTX2/Basis Universal支持的游戏引擎，打包移动平台WebH5游戏时需要采用不同的策略。

#### 3.7.0 关键问题：为什么不能直接用ASTC？

**重要区别：原生平台 vs WebH5平台**

虽然现代移动设备硬件都支持ASTC（Android 5.0+，iOS 9+），但**WebH5环境无法直接利用这一点**。

| 对比维度 | 原生应用（Cocos/Unity导出） | WebH5应用（浏览器中运行） |
|---------|--------------------------|------------------------|
| **API层级** | OpenGL ES直接访问GPU | WebGL通过浏览器访问GPU |
| **ASTC支持** | 硬件支持即可用 | 需要浏览器暴露WebGL扩展 |
| **格式检测** | `glGetString(GL_EXTENSIONS)` | `gl.getExtension('WEBGL_compressed_texture_astc')` |
| **兼容性** | ✅ 接近100%（现代设备） | ⚠️ 取决于浏览器支持 |

**核心问题：WebGL扩展支持现状**

截至2024年，`WEBGL_compressed_texture_astc`扩展的支持情况：

1. **Android Chrome/Edge**：
   - ❌ 不支持ASTC扩展（即使硬件支持）
   - ✅ 支持ETC1扩展（`WEBGL_compressed_texture_etc1`）
   - ✅ 部分支持ETC2扩展（`WEBGL_compressed_texture_etc`，较新版本）

2. **iOS Safari**：
   - ❌ 不支持ASTC扩展（虽然硬件完美支持）
   - ✅ 支持PVRTC扩展（`WEBGL_compressed_texture_pvrtc`）

3. **桌面浏览器**：
   - ✅ Chrome/Firefox：支持S3TC (DXT)
   - ❌ 多数不支持ASTC

**为什么浏览器不暴露ASTC扩展？**

1. **标准化进程缓慢**：WebGL扩展需要Khronos标准化，ASTC扩展虽然存在但未被广泛实现
2. **安全性考虑**：浏览器需要确保扩展不会暴露安全风险
3. **兼容性优先**：浏览器厂商优先支持更通用的格式（ETC、PVRTC）
4. **历史原因**：ETC/PVRTC扩展更早被标准化

**实际测试（2024年）：**

```javascript
// 在移动设备浏览器中测试
const canvas = document.createElement('canvas');
const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

console.log('ASTC支持:', gl.getExtension('WEBGL_compressed_texture_astc')); // null
console.log('ETC1支持:', gl.getExtension('WEBGL_compressed_texture_etc1')); // Android: object, iOS: null
console.log('PVRTC支持:', gl.getExtension('WEBGL_compressed_texture_pvrtc')); // iOS: object, Android: null
```

**完整的浏览器扩展检测示例（可直接在浏览器控制台运行）：**

```javascript
function checkWebGLTextureSupport() {
    const canvas = document.createElement('canvas');
    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
    
    if (!gl) {
        console.error('WebGL不支持');
        return;
    }
    
    console.log('=== WebGL纹理压缩格式支持情况 ===');
    
    const formats = [
        { name: 'ASTC', ext: 'WEBGL_compressed_texture_astc' },
        { name: 'ETC1', ext: 'WEBGL_compressed_texture_etc1' },
        { name: 'ETC2', ext: 'WEBGL_compressed_texture_etc' },
        { name: 'PVRTC', ext: 'WEBGL_compressed_texture_pvrtc' },
        { name: 'PVRTC (WebKit)', ext: 'WEBKIT_WEBGL_compressed_texture_pvrtc' },
        { name: 'S3TC (DXT)', ext: 'WEBGL_compressed_texture_s3tc' },
        { name: 'S3TC (WebKit)', ext: 'WEBKIT_WEBGL_compressed_texture_s3tc' },
    ];
    
    formats.forEach(format => {
        const supported = gl.getExtension(format.ext);
        console.log(`${format.name}: ${supported ? '✅ 支持' : '❌ 不支持'}`);
    });
    
    // 显示所有可用的扩展
    console.log('\n所有WebGL扩展:');
    const extensions = gl.getSupportedExtensions();
    extensions.forEach(ext => {
        if (ext.includes('texture') || ext.includes('compress')) {
            console.log(`  - ${ext}`);
        }
    });
}

// 运行检测
checkWebGLTextureSupport();
```

**典型输出结果：**

```
Android Chrome (2024):
  ASTC: ❌ 不支持
  ETC1: ✅ 支持
  ETC2: ✅ 支持（较新版本）
  PVRTC: ❌ 不支持
  S3TC: ❌ 不支持

iOS Safari (2024):
  ASTC: ❌ 不支持
  ETC1: ❌ 不支持
  ETC2: ❌ 不支持
  PVRTC: ✅ 支持
  S3TC: ❌ 不支持
```

**结论：**
- **原生平台**（Cocos/Unity导出APK/IPA）：✅ 可以统一使用ASTC，硬件直接支持
- **WebH5平台**（浏览器中运行）：❌ 不能使用ASTC，必须使用ETC/PVRTC或降级方案

这就是为什么WebH5游戏需要3.7节介绍的复杂策略，而原生打包则可以简单地全用ASTC。

#### 3.7.1 面临的挑战

**移动Web平台的复杂性：**
1. **平台碎片化**：
   - Android设备：GPU品牌众多（Adreno、Mali、PowerVR等）
   - iOS设备：统一使用PowerVR GPU（较新设备使用Apple GPU）
   - 不同GPU支持的压缩格式不同

2. **WebGL扩展支持不一致**：
   - 不是所有移动浏览器都支持所有压缩纹理扩展
   - 需要运行时检测扩展支持情况

3. **包体大小限制**：
   - H5游戏对包体大小敏感
   - 需要在质量和体积间平衡

#### 3.7.2 方案一：传统磁盘格式 + 运行时解码（推荐兼容性方案）

**策略：使用PNG或WebP作为磁盘格式**

**优点：**
- ✅ 100%兼容性，所有浏览器都支持
- ✅ 磁盘占用小（PNG/WebP压缩率高）
- ✅ 实现简单，无需平台检测
- ✅ 适合小型H5游戏

**缺点：**
- ❌ GPU显存占用大（解码后为未压缩RGBA）
- ❌ CPU解码开销
- ❌ 上传带宽大（传输未压缩数据到GPU）

**适用场景：**
- 纹理数量少（< 50张）
- 纹理尺寸小（多数< 512×512）
- 对兼容性要求极高
- 首屏加载要求快

**实现示例：**
```javascript
// 使用WebP格式（比PNG更小）
async function loadTexture(gl, url) {
    const image = new Image();
    image.src = url; // 例如 'textures/character.webp'
    await image.decode();
    
    const texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
    gl.generateMipmap(gl.TEXTURE_2D);
    
    return texture;
}
```

**格式选择：**
```
优先级：WebP > PNG > JPEG（不推荐JPEG，质量损失大且不支持Alpha）

WebP优势：
- 有损压缩：比JPEG小30%，质量相近
- 无损压缩：比PNG小26%
- 支持Alpha通道
- 移动浏览器支持良好（iOS 14+、Android Chrome全支持）
```

#### 3.7.3 方案二：多格式打包 + 运行时选择（推荐性能方案）

**策略：为不同平台准备不同的压缩纹理格式**

这是移动H5游戏的最佳实践方案，虽然实现复杂，但能显著优化性能。

**核心思路：**
1. 构建时生成多种格式的纹理文件
2. 运行时检测WebGL扩展支持
3. 动态加载对应格式的纹理

**需要准备的格式：**

| 平台 | 格式 | WebGL扩展 | 文件后缀 |
|------|------|-----------|---------|
| Android (多数) | ETC1 | WEBGL_compressed_texture_etc1 | .etc1.ktx |
| Android (较新) | ETC2 | WEBGL_compressed_texture_etc | .etc2.ktx |
| iOS | PVRTC | WEBGL_compressed_texture_pvrtc | .pvr |
| 桌面/降级 | WebP/PNG | - | .webp/.png |

**实现步骤：**

**步骤1：构建时生成多格式纹理**

```bash
# 使用PVRTexTool或类似工具离线转换
# 从原始PNG生成各种压缩格式

# 生成ETC1（Android旧设备）
PVRTexToolCLI -i texture.png -o texture.etc1.ktx -f ETC1

# 生成ETC2（Android新设备）
PVRTexToolCLI -i texture.png -o texture.etc2.ktx -f ETC2_RGBA

# 生成PVRTC（iOS）
PVRTexToolCLI -i texture.png -o texture.pvr -f PVRTC1_4_RGB

# 保留WebP作为降级方案
cwebp texture.png -o texture.webp -q 85
```

**步骤2：运行时检测扩展支持**

```javascript
class TextureFormatDetector {
    constructor(gl) {
        this.gl = gl;
        this.supportedFormat = this.detectBestFormat();
    }
    
    detectBestFormat() {
        const gl = this.gl;
        
        // 检测PVRTC（iOS优先）
        if (gl.getExtension('WEBGL_compressed_texture_pvrtc') ||
            gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc')) {
            return {
                type: 'PVRTC',
                ext: 'pvr',
                internalFormat: 0x8C01 // COMPRESSED_RGBA_PVRTC_4BPPV1_IMG
            };
        }
        
        // 检测ETC2（Android新设备）
        const etc2Ext = gl.getExtension('WEBGL_compressed_texture_etc');
        if (etc2Ext) {
            return {
                type: 'ETC2',
                ext: 'etc2.ktx',
                internalFormat: etc2Ext.COMPRESSED_RGBA8_ETC2_EAC
            };
        }
        
        // 检测ETC1（Android旧设备）
        const etc1Ext = gl.getExtension('WEBGL_compressed_texture_etc1');
        if (etc1Ext) {
            return {
                type: 'ETC1',
                ext: 'etc1.ktx',
                internalFormat: etc1Ext.COMPRESSED_RGB_ETC1_WEBGL
            };
        }
        
        // 降级到未压缩格式
        return {
            type: 'UNCOMPRESSED',
            ext: 'webp',
            internalFormat: null
        };
    }
    
    getTexturePath(baseName) {
        return `textures/${baseName}.${this.supportedFormat.ext}`;
    }
}
```

**步骤3：加载对应格式的纹理**

```javascript
class TextureLoader {
    constructor(gl, detector) {
        this.gl = gl;
        this.detector = detector;
    }
    
    async loadCompressedTexture(baseName) {
        const format = this.detector.supportedFormat;
        const url = this.detector.getTexturePath(baseName);
        
        if (format.type === 'UNCOMPRESSED') {
            // 降级方案：加载WebP/PNG
            return this.loadUncompressedTexture(url);
        }
        
        // 加载压缩纹理文件
        const response = await fetch(url);
        const arrayBuffer = await response.arrayBuffer();
        
        // 解析KTX/PVR文件格式（需要解析文件头）
        const textureData = this.parseCompressedFile(arrayBuffer, format.type);
        
        // 上传到GPU
        const texture = this.gl.createTexture();
        this.gl.bindTexture(this.gl.TEXTURE_2D, texture);
        
        // 使用compressedTexImage2D上传压缩数据
        this.gl.compressedTexImage2D(
            this.gl.TEXTURE_2D,
            0, // level
            format.internalFormat,
            textureData.width,
            textureData.height,
            0, // border
            new Uint8Array(arrayBuffer, textureData.dataOffset)
        );
        
        return texture;
    }
    
    async loadUncompressedTexture(url) {
        const image = new Image();
        image.src = url;
        await image.decode();
        
        const texture = this.gl.createTexture();
        this.gl.bindTexture(this.gl.TEXTURE_2D, texture);
        this.gl.texImage2D(
            this.gl.TEXTURE_2D, 0, this.gl.RGBA,
            this.gl.RGBA, this.gl.UNSIGNED_BYTE, image
        );
        
        return texture;
    }
    
    parseCompressedFile(arrayBuffer, formatType) {
        // 简化示例，实际需要完整的KTX/PVR解析器
        // 参考：https://github.com/BabylonJS/Babylon.js/blob/master/packages/dev/loaders/src/glTF/2.0/Extensions/KHR_texture_basisu.ts
        
        if (formatType === 'PVRTC') {
            return this.parsePVR(arrayBuffer);
        } else {
            return this.parseKTX(arrayBuffer);
        }
    }
    
    parseKTX(arrayBuffer) {
        // KTX文件格式解析
        const view = new DataView(arrayBuffer);
        // ... 解析KTX文件头 ...
        return {
            width: 512,  // 从文件头读取
            height: 512,
            dataOffset: 64 // 数据偏移量
        };
    }
}
```

**优点：**
- ✅ GPU显存占用小（使用压缩格式）
- ✅ 渲染性能好（GPU硬件解码）
- ✅ 支持大量纹理的游戏
- ✅ 兼容性好（有降级方案）

**缺点：**
- ❌ 实现复杂，需要文件格式解析
- ❌ 构建流程复杂，需要生成多种格式
- ❌ 包体增大（需要携带多种格式，可通过CDN按需加载解决）

**适用场景：**
- 中大型H5游戏
- 纹理数量多或尺寸大
- 对性能要求高
- 可接受一定开发成本

#### 3.7.4 方案三：混合策略（推荐平衡方案）

**策略：根据纹理重要性采用不同格式**

将纹理分为几类，采用不同的格式策略：

**分类策略：**

1. **UI纹理**（按钮、图标等）
   - 特点：尺寸小、数量多、需要高质量
   - 格式：WebP（磁盘） + 未压缩RGBA（GPU）
   - 理由：小纹理压缩收益不明显，WebP磁盘占用小

2. **场景纹理**（地面、墙壁等）
   - 特点：尺寸大、数量少、可接受质量损失
   - 格式：压缩纹理（ETC1/PVRTC） + WebP降级
   - 理由：大纹理压缩收益明显，显存节省重要

3. **角色纹理**（主角、重要NPC）
   - 特点：中等尺寸、质量要求高
   - 格式：压缩纹理（ETC2/PVRTC） + WebP降级
   - 理由：兼顾质量和显存占用

**实现示例：**

```javascript
const textureConfig = {
    'ui/button.png': { strategy: 'uncompressed', format: 'webp' },
    'ui/icon.png': { strategy: 'uncompressed', format: 'webp' },
    
    'scene/ground.png': { strategy: 'compressed', priority: 'size' },
    'scene/wall.png': { strategy: 'compressed', priority: 'size' },
    
    'character/hero.png': { strategy: 'compressed', priority: 'quality' },
};

async function loadTexture(baseName) {
    const config = textureConfig[baseName];
    
    if (config.strategy === 'uncompressed') {
        return loadWebPTexture(baseName);
    } else {
        return loadCompressedTexture(baseName, config.priority);
    }
}
```

#### 3.7.5 实战建议

**对于不同规模的H5游戏：**

1. **小型休闲游戏**（< 10MB包体）
   ```
   推荐：方案一（WebP + 未压缩）
   原因：实现简单，兼容性好，性能足够
   ```

2. **中型H5游戏**（10-30MB包体）
   ```
   推荐：方案三（混合策略）
   原因：平衡开发成本和性能，关键纹理使用压缩格式
   关键：
   - UI使用WebP
   - 场景大纹理使用ETC1/PVRTC（带WebP降级）
   ```

3. **大型H5游戏**（> 30MB包体）
   ```
   推荐：方案二（多格式打包）
   原因：必须优化显存占用，否则低端设备无法运行
   额外优化：
   - CDN按需加载，不同平台分发不同格式
   - 实现纹理流式加载
   - 考虑纹理图集（Texture Atlas）
   ```

**CDN优化策略：**

```javascript
// 根据UA检测，从CDN加载对应平台的资源包
function getCDNPath(textureName) {
    const platform = detectPlatform(); // 'ios', 'android', 'desktop'
    return `https://cdn.example.com/textures/${platform}/${textureName}`;
}

function detectPlatform() {
    const ua = navigator.userAgent;
    if (/iPhone|iPad|iPod/.test(ua)) return 'ios';
    if (/Android/.test(ua)) return 'android';
    return 'desktop';
}

// 这样可以避免在包体中携带所有格式
// iOS设备只下载.pvr文件
// Android设备只下载.etc1/.etc2文件
```

#### 3.7.6 工具链推荐

**纹理转换工具：**

1. **PVRTexTool** (Imagination Technologies)
   - 支持：PVRTC, ETC1, ETC2, ASTC
   - 平台：Windows, macOS, Linux
   - 命令行版本适合集成到构建流程

2. **Mali Texture Compression Tool** (ARM)
   - 支持：ETC1, ETC2, ASTC
   - 优化：针对Mali GPU优化
   - 适合：Android平台

3. **自动化构建脚本示例：**

```javascript
// build-textures.js
const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

const texturesDir = 'assets/textures';
const outputDir = 'dist/textures';

// 读取所有PNG文件
const textures = fs.readdirSync(texturesDir)
    .filter(f => f.endsWith('.png'));

textures.forEach(texture => {
    const baseName = path.basename(texture, '.png');
    const input = path.join(texturesDir, texture);
    
    // 生成WebP（降级方案）
    execSync(`cwebp ${input} -o ${outputDir}/${baseName}.webp -q 85`);
    
    // 生成ETC1（Android）
    execSync(`PVRTexToolCLI -i ${input} -o ${outputDir}/${baseName}.etc1.ktx -f ETC1`);
    
    // 生成PVRTC（iOS）
    execSync(`PVRTexToolCLI -i ${input} -o ${outputDir}/${baseName}.pvr -f PVRTC1_4`);
    
    console.log(`✓ Processed: ${texture}`);
});
```

#### 3.7.7 性能对比

**假设场景：50张512×512 RGBA纹理的H5游戏**

| 方案 | 磁盘占用 | GPU显存占用 | 首屏加载时间 | 兼容性 | 开发成本 |
|------|---------|------------|------------|--------|---------|
| 方案一（WebP） | 15 MB | 50 MB | 2-3秒 | 100% | 低 |
| 方案二（多格式） | 30 MB* | 12.5 MB | 3-4秒 | 98% | 高 |
| 方案三（混合） | 20 MB | 30 MB | 2.5-3.5秒 | 99% | 中 |

**说明：**
- 方案二虽然打包体积大，但通过CDN按平台分发后，实际下载量约15MB
- GPU显存占用差异巨大（50MB vs 12.5MB），影响低端设备兼容性
- 开发成本包括构建流程、运行时检测、文件解析等

---

## 4. 总结

### 4.1 核心要点

**内存管理：**
1. **CPU内存**：存储解码后的像素数据，应在`glTexImage2D`后立即释放
2. **GPU显存**：存储纹理对象，通过`glDeleteTextures`在不需要时释放
3. **独立性**：两者完全独立，没有引用关系
4. **最佳实践**：解绑 → 删除GPU纹理 → 确认CPU内存已释放

**格式选择：**
1. **平台优先**：根据目标平台选择合适的GPU压缩格式
   - **原生Android**: ASTC 4×4（推荐） > ETC2 > ETC1
   - **原生iOS**: ASTC 4×4（推荐） > PVRTC 4bpp
   - **WebH5 Android**: ETC2 > ETC1（ASTC不可用）
   - **WebH5 iOS**: PVRTC 4bpp（ASTC不可用）
   - **Web桌面**: S3TC (DXT)
   
2. **显存优化**：使用GPU压缩纹理可节省75%-87.5%的显存
   - 未压缩RGBA: 4 bytes/pixel
   - DXT5/ETC2: ~1 byte/pixel (4:1)
   - PVRTC 4bpp: ~0.5 bytes/pixel (8:1)

3. **原生 vs WebH5的关键区别**：
   - **原生平台**（APK/IPA）：可统一使用ASTC，硬件直接支持
   - **WebH5平台**（浏览器）：ASTC不可用，需用ETC/PVRTC + 降级方案

4. **WebH5游戏策略**：
   - 小型游戏：WebP + 未压缩（简单兼容）
   - 中型游戏：混合策略（平衡性能）
   - 大型游戏：多格式打包 + CDN分发（最优性能）

**三种空间占用：**
- **磁盘占用**：PNG/WebP压缩，优化下载
- **CPU内存**：解码后RGBA，临时使用
- **GPU显存**：压缩或未压缩，长期占用

正确管理内存和选择合适的纹理格式，可以显著提升应用程序的性能、兼容性和稳定性。